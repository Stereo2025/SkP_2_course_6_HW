from random import sample


# -------------------------------------------------------------------------------------------------------------- #
# Функция main является логикой данного приложения. В начале пользователь вводит своё имя, что бы программа его
# запомнила и в дальнейшем записала в файл. Далее присваиваем переменной words функцию read_words('words.txt'),
# которая прочитает слова из файла и вернётся к нам списком.Заведем счетчик для подсчета баллов.
# Начнем цикл for по переменной words, поскольку результат функции в ней уже саккумулирован, цикл будет делать
# итерации по списку, а затем переменная sample_word, поскольку находится в теле цикла и ссылается на функцию
# word_sample(word) будет перехватывать каждое слово для перемешивания в нем букв и возврата значения обратно
# в себя. Затем попросим пользователя отгадать перемешанное слово, приведя его ответ к нижнему регистру на всякий
# случай. Если ответ верный, + 10 баллов, если нет - выводим правильный ответ.
# В конце нам остаётся только вызвать функцию record_top_players в которую мы передали аргументы в виде файла для
# записи истории, именем пользователя и счетчика баллов, а также функцию reading_top_players с аргументом в виде
# файла с историей, в который уже записаны все необходимые данные. "Вызовем её через print()".


def main():

    """
    Основная функция с логикой
    :return: Результат работы всей программы. Запись игрока в топ, вывод результата игры.
    """
    user_name = input('Enter your name: ')
    while user_name != 'stop':
        words = read_words('words.txt')  # <-------- str.52
        points_counter = 0

        for word in words:
            sample_word = word_sample(word)  # <-------- str.75
            user_input = input(f'Guess the word: {sample_word} - ').lower()

            if user_input == word:
                points_counter += 10
                print(f'That right, you get 10 points.', end='\n' * 2)
            else:
                print(f'Wrong, the right word is - {word}', end='\n' * 2)

        record_top_players(history='history.txt', user=user_name, score=points_counter)  # --------> str.93
        print(reading_top_players(history='history.txt'), "\n")  # --------> str.116

        user_name = input('Do you want to play again? If yes, enter your name, if no, enter "stop"\n: ')
        if user_name == 'stop':
            print('See you!')

# -------------------------------------------------------------------------------------------------------------- #
# Функция read_words с аргументом (file_words) который является txt файлом из которого будут читаться слова.
# Слова будут аккумулироваться в "list comprehension - генератор списков". return будет возвращать готовый
# для работы сгенерированный список со словами из файла.


def read_words(file_words: str):  # --------> str.26

    """
    Читает слова из файлы words.txt
    :param file_words: words.txt
    :return: Сгенерированный список со словами из файла.
    """
    with open(file_words, encoding='utf-8') as text:
        result = [i.strip() for i in text.readlines()]
    return result


# -------------------------------------------------------------------------------------------------------------- #
# Функция word_sample с аргументом word который является переменной цикла for в функции main(),
# который в свою очередь делает итерации по переменной words, которая ссылается на функцию read_words,
# и которая уже прочитала слова из списка words.txt. Разместив sample_word в теле цикла for функции main
# мы добиваемся того, что в каждую новую итерацию, в данную функцию будет приходить следующее слово
# для перемешивания букв. Мешать буквы мы будем функцией sample, которая возвращает список n длинны
# случайных элементов из выбранной последовательности, строки/списка/кортежа. В нашем случае это слово,
# по которому бежит цикл for и длинна слова. Поскольку sample возвращает "список" символов, нам нужно
# на выход склеить перемешанный список из букв в слово, делаем это с помощью join и возвращаем в main.


def word_sample(word: str):  # --------> str.30

    """
    Перемешивает буквы в слове.
    :param word: - это циклическая переменная которая совершает итерации по списку со словами.
    :return: перемешанное слово.
    """
    result = sample(word, len(word))
    return "".join(result)


# -------------------------------------------------------------------------------------------------------------- #
# Функция record_top_players с аргументами в виде 1) - файла history.txt 2) - именем пользователя
# 3) - количеством очков, которые набрал пользователь за игру и 4) - разделителем.
# Далее с помощью переменной user_result и f строки, мы передадим в ней аргументы из функции record_top_players
# которые к этому моменту уже записали и обработали необходимые данные в предыдущих функциях и отработали в main.


def record_top_players(history, user, score, sep=': '):  # <-------- str.39

    """
    Ведет запись топ игроков в топ.
    :param history: history.txt
    :param user: Имя пользователя
    :param score: Количество набранных баллов
    :param sep: Разделитель для удобства чтения
    :return: ничего не возвращает, а только принимает в себя готовые для записи параметры из main()
    """
    user_result = f'{user}{sep}{score}\n'
    with open(history, 'a', encoding='utf-8') as text:
        text.write(user_result)


# -------------------------------------------------------------------------------------------------------------- #
# Функция reading_top_players имеет один аргумент в виде файла history.txt| для чтения результатов всех игр.
# В функции две переменные 1) - count_games - который считает количество игр, и 2) - count_scores - список,
# который будет записывать в себя все имеющиеся данные после ": " . После подсчета результатов данные перемен-
# ные будут отправленные в return для объявления результат игр. Для вывода максимального балла используем функцию
# max() к списку.


def reading_top_players(history: str):  # <-------- str.40

    """
    Читает из файла результаты игр.
    :param history: history.txt с готовыми параметрами.
    :return: результат с количеством игр и максимальным рейтингом.
    """
    with open(history, encoding='utf-8') as text:
        count_games, count_scores = 0, []

        for i in text:
            name, score = i.strip().split(': ')
            count_games += 1
            count_scores.append(score)

    return f'Total games played: {count_games}, the maximum record is: {max(count_scores)}'


# -------------------------------------------------------------------------------------------------------------- #
# Данный паттерн является началом "инициализатором" старта программы.


if __name__ == '__main__':
    main()
##################################################################################################################
